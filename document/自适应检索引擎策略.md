# 自适应检索引擎策略设计文档

## 1. 背景与目标

### 1.1 设计背景
基于对用户查询的分析，发现用户问题可以归纳为几个大类：
1. **简单规则查询**：如"冲锋规则是什么"
2. **单位+规则的逻辑推理**：如"阿巴顿的黑色远征对帝国有什么影响"
3. **穷举数据库里某一类特征**：如"列出所有混沌单位"

发现RAG在处理类型2、3的查询时效果较差，需要针对不同查询类型采用不同的检索和答案生成策略。

### 1.2 设计目标
实现一种自适应模式，在QueryProcessor中先对query做语义解析，根据不同类型语义去使用不同的检索和答案生成策略。在检索召回阶段增加Post-Search环节，用于对检索结果进行进一步处理。

## 2. 当前架构分析

### 2.1 现有架构优势

- **工厂模式**：`QueryProcessorFactory`、`SearchEngineFactory`、`AggFactory`
- **统一接口**：每个模块都有标准接口
- **Orchestrator模式**：`RAGOrchestrator` 统一调度
- **参数化配置**：通过命令行参数动态选择不同实现

### 2.2 架构组件

用户查询 → QueryProcessor → SearchEngine → Aggregator → 最终答案

## 3. 自适应模式设计方案

### 3.1 整体架构

用户查询 → 自适应QueryProcessor → 自适应SearchEngine → Post-Search → 自适应Aggregator → 最终答案


### 3.2 查询类型识别与路由

#### 3.2.1 自适应查询处理器
```python
class AdaptiveQueryProcessor(QueryProcessorInterface):
    """自适应查询处理器 - 根据查询语义自动选择处理策略"""
    
    def __init__(self):
        self.query_classifier = QueryTypeClassifier()
        self.processors = {
            'simple_rule': StraightforwardProcessor(),
            'complex_reasoning': COTProcessor(), 
            'enumeration': ExpanderQueryProcessor()
        }
    
    def process(self, query: str) -> Dict[str, Any]:
        # 1. 查询类型识别
        query_type = self.query_classifier.classify(query)
        
        # 2. 选择对应的处理器
        processor = self.processors[query_type]
        
        # 3. 处理查询
        processed = processor.process(query)
        
        # 4. 添加路由信息
        return {
            'original_query': query,
            'query_type': query_type,
            'processor_used': processor.get_type(),
            'processed_query': processed,
            'routing_strategy': self._get_routing_strategy(query_type)
        }
```

#### 3.2.2 查询类型分类器
```python
class QueryTypeClassifier:
    """查询类型分类器"""
    
    def classify(self, query: str) -> str:
        """
        根据查询语义分类：
        1. simple_rule: 简单规则查询
        2. complex_reasoning: 单位+规则的逻辑推理
        3. enumeration: 穷举数据库里某一类特征
        """
        # 使用LLM进行语义分类
        classification_prompt = f"""
        分析以下战锤40K查询的类型：
        查询：{query}
        
        请从以下三种类型中选择：
        1. simple_rule: 简单规则查询（如"冲锋规则是什么"）
        2. complex_reasoning: 复杂逻辑推理（如"阿巴顿的黑色远征对帝国有什么影响"）
        3. enumeration: 穷举查询（如"列出所有混沌单位"）
        
        只返回类型名称，如：simple_rule
        """
        
        response = call_llm(classification_prompt)
        return response.strip().lower()
```

### 3.3 自适应搜索引擎

```python
class AdaptiveSearchEngine(SearchEngineInterface):
    """自适应搜索引擎 - 根据查询类型选择检索策略"""
    
    def __init__(self):
        self.search_strategies = {
            'simple_rule': DenseSearchEngine(),  # 简单向量检索
            'complex_reasoning': HybridSearchEngine(),  # 混合检索+KG
            'enumeration': EnumerationSearchEngine()  # 专门处理穷举查询
        }
    
    def search(self, processed_query: Dict[str, Any], top_k: int = 10) -> List[Dict[str, Any]]:
        query_type = processed_query['query_type']
        
        # 选择搜索策略
        search_engine = self.search_strategies[query_type]
        results = search_engine.search(processed_query['processed_query'], top_k)
        
        return results
```

### 3.4 专门的处理策略

#### 3.4.1 穷举查询引擎

```python
class EnumerationSearchEngine(SearchEngineInterface):
    """专门处理穷举查询的搜索引擎"""
    
    def search(self, query: str, top_k: int = 50) -> List[Dict[str, Any]]:
        # 1. 识别要穷举的类别
        category = self._extract_category(query)
        
        # 2. 使用元数据过滤
        filter_dict = {
            'chunk_type': {'$contains': category}
        }
        
        # 3. 扩大检索范围，获取所有相关项
        results = self.index.query(
            vector=query_embedding,
            filter=filter_dict,
            top_k=100,  # 更大的检索范围
            include_metadata=True
        )
        
        # 4. 去重和结构化
        return self._deduplicate_and_structure(results, category)
```

#### 3.4.2 复杂推理引擎

```python
class ComplexReasoningEngine(SearchEngineInterface):
    """处理复杂逻辑推理的搜索引擎"""
    
    def search(self, query: str, top_k: int = 10) -> List[Dict[str, Any]]:
        # 1. 实体关系抽取
        entities, relations = self._extract_entities_relations(query)
        
        # 2. 多跳检索
        results = []
        for entity in entities:
            # 直接相关
            direct_results = self._search_entity(entity)
            results.extend(direct_results)
            
            # 关系检索
            for relation in relations:
                related_results = self._search_relations(entity, relation)
                results.extend(related_results)
        
        # 3. 结果重排序（基于推理链）
        return self._rerank_by_reasoning_chain(results, query)
```

### 3.5 自适应聚合器

```python
class AdaptiveAggregator(AggregationInterface):
    """自适应聚合器 - 根据查询类型选择聚合策略"""
    
    def aggregate(self, results: List[Dict], query: str, params: Dict = None) -> Dict[str, Any]:
        # 1. 从结果中提取查询类型信息
        query_type = self._extract_query_type_from_results(results)
        
        # 2. 选择聚合策略
        if query_type == 'simple_rule':
            return self._simple_aggregate(results, query)
        elif query_type == 'complex_reasoning':
            return self._reasoning_aggregate(results, query)
        elif query_type == 'enumeration':
            return self._enumeration_aggregate(results, query)
```

## 4. Post-Search 模块设计

### 4.1 推荐方案：独立模块 + 管道模式

经过分析，推荐采用**独立模块**，通过**管道模式**来简化接口：

#### 4.1.1 方案对比

##### 方案1：Post-Search 作为 SearchEngine 的一部分

- 优点：职责内聚、数据流简单、性能优化、接口简洁
- 缺点：模块耦合、扩展性受限、测试复杂

##### 方案2：Post-Search 作为独立模块

- 优点：高度解耦、灵活组合、易于扩展、可复用性
- 缺点：接口复杂、数据传递开销、调试困难

**推荐方案：独立模块 + 管道模式**

### 4.2 具体实现

#### 4.2.1 Post-Search 独立模块

```python
class PostSearchPipeline:
    """Post-Search 处理管道"""
    
    def __init__(self):
        self.processors = {
            'rerank': RerankProcessor(),
            'mmr': MMRProcessor(),
            'filter': FilterProcessor(),
            'dedup': DedupProcessor()
        }
    
    def process(self, results: List[Dict], strategy: List[str], **kwargs) -> List[Dict]:
        """按策略顺序处理结果"""
        processed_results = results
        
        for processor_name in strategy:
            if processor_name in self.processors:
                processor = self.processors[processor_name]
                processed_results = processor.process(processed_results, **kwargs)
        
        return processed_results
```

#### 4.2.2 在 Orchestrator 中组合

```python
class AdaptiveRAGOrchestrator:
    def __init__(self, query_processor, search_engine, aggregator):
        self.qp = query_processor
        self.se = search_engine
        self.agg = aggregator
        self.post_search = PostSearchPipeline()  # 独立模块
    
    def run(self, query: str, top_k: int = 5, **kwargs) -> Any:
        # 1. 查询处理
        processed = self.qp.process(query)
        
        # 2. 检索召回
        results = self.se.search(processed, top_k=top_k)
        
        # 3. Post-Search 处理（独立模块）
        post_search_strategy = self._get_post_search_strategy(processed)
        if post_search_strategy:
            results = self.post_search.process(
                results, 
                strategy=post_search_strategy,
                query_info=processed
            )
        
        # 4. 聚合
        result = self.agg.aggregate(results, query, params=kwargs)
        return result
```

### 4.3 模块结构设计

### 4.1 架构选择：独立模块 + 管道模式

经过分析，推荐采用**独立模块**，通过**管道模式**来简化接口：

#### 4.1.1 方案对比

**方案1：Post-Search 作为 SearchEngine 的一部分**

- 优点：职责内聚、数据流简单、性能优化、接口简洁
- 缺点：模块耦合、扩展性受限、测试复杂

**方案2：Post-Search 作为独立模块**

- 优点：高度解耦、灵活组合、易于扩展、可复用性
- 缺点：接口复杂、数据传递开销、调试困难

**推荐方案：独立模块 + 管道模式**

### 4.2 具体实现

#### 4.2.1 Post-Search 独立模块

```python
class PostSearchPipeline:
    """Post-Search 处理管道"""
    
    def __init__(self):
        self.processors = {
            'rerank': RerankProcessor(),
            'mmr': MMRProcessor(),
            'filter': FilterProcessor(),
            'dedup': DedupProcessor()
        }
    
    def process(self, results: List[Dict], strategy: List[str], **kwargs) -> List[Dict]:
        """按策略顺序处理结果"""
        processed_results = results
        
        for processor_name in strategy:
            if processor_name in self.processors:
                processor = self.processors[processor_name]
                processed_results = processor.process(processed_results, **kwargs)
        
        return processed_results
```

#### 4.2.2 在 Orchestrator 中组合

```python
class AdaptiveRAGOrchestrator:
    def __init__(self, query_processor, search_engine, aggregator):
        self.qp = query_processor
        self.se = search_engine
        self.agg = aggregator
        self.post_search = PostSearchPipeline()  # 独立模块
    
    def run(self, query: str, top_k: int = 5, **kwargs) -> Any:
        # 1. 查询处理
        processed = self.qp.process(query)
        
        # 2. 检索召回
        results = self.se.search(processed, top_k=top_k)
        
        # 3. Post-Search 处理（独立模块）
        post_search_strategy = self._get_post_search_strategy(processed)
        if post_search_strategy:
            results = self.post_search.process(
                results, 
                strategy=post_search_strategy,
                query_info=processed
            )
        
        # 4. 聚合
        result = self.agg.aggregate(results, query, params=kwargs)
        return result
```

### 4.3 模块结构设计

searchengine/
├── init.py
├── search_interface.py
├── dense_search.py
├── hybrid_search.py
└── ...
postsearch/
├── init.py
├── pipeline.py # 管道主类
├── processors/
│ ├── init.py
│ ├── rerank.py
│ ├── mmr.py
│ ├── filter.py
│ └── dedup.py
└── interfaces.py # 处理器接口


### 4.4 处理器接口设计

```python
class PostSearchProcessor(ABC):
    """Post-Search 处理器接口"""
    
    @abstractmethod
    def process(self, results: List[Dict], **kwargs) -> List[Dict]:
        """处理检索结果"""
        pass
    
    @abstractmethod
    def get_name(self) -> str:
        """获取处理器名称"""
        pass
    
    @abstractmethod
    def get_config_schema(self) -> Dict:
        """获取配置模式"""
        pass
```

### 4.5 具体处理器实现

```python
class RerankProcessor(PostSearchProcessor):
    """重排序处理器"""
    
    def process(self, results: List[Dict], **kwargs) -> List[Dict]:
        # 使用更精细的排序模型
        return self._cross_encoder_rerank(results, kwargs.get('query'))

class MMRProcessor(PostSearchProcessor):
    """MMR多样性处理器"""
    
    def process(self, results: List[Dict], **kwargs) -> List[Dict]:
        # 最大化边际相关性，增加结果多样性
        return self._mmr_diversify(results, lambda_param=0.5)
```

### 4.6 配置化策略

```python
# config/post_search_config.py
POST_SEARCH_STRATEGIES = {
    'simple_rule': [],  # 简单规则查询不需要后处理
    'complex_reasoning': ['rerank', 'mmr'],  # 复杂推理需要重排序和多样性
    'enumeration': ['dedup', 'mmr']  # 穷举查询需要去重和多样性
}
```

### 4.7 工厂模式集成

```python
class PostSearchFactory:
    """Post-Search 工厂类"""
    
    @staticmethod
    def create_pipeline(strategy: List[str]) -> PostSearchPipeline:
        """根据策略创建处理管道"""
        pipeline = PostSearchPipeline()
        # 可以在这里添加策略验证和优化
        return pipeline
```

## 5. 配置化设计

### 5.1 自适应策略配置

```python
# config/adaptive_config.py
ADAPTIVE_STRATEGIES = {
    'simple_rule': {
        'processor': 'straight',
        'search_engine': 'dense',
        'post_search': [],
        'aggregator': 'simple'
    },
    'complex_reasoning': {
        'processor': 'cot',
        'search_engine': 'hybrid',
        'post_search': ['rerank', 'mmr'],
        'aggregator': 'reasoning'
    },
    'enumeration': {
        'processor': 'expand',
        'search_engine': 'enumeration',
        'post_search': ['mmr'],
        'aggregator': 'enumeration'
    }
}
```

## 6. 实施建议

### 6.1 渐进式实施
1. **第一阶段**：实现查询类型分类器
2. **第二阶段**：添加自适应路由逻辑
3. **第三阶段**：实现专门的搜索引擎
4. **第四阶段**：添加Post-Search处理

### 6.2 评估与优化
- 为每种查询类型建立专门的评估指标
- 实现A/B测试框架，对比自适应模式与固定模式的效果
- 收集用户反馈，持续优化分类器和策略

### 6.3 为什么选择独立模块？

1. **符合现有架构风格**：现有的 `qProcessor`、`searchEngine`、`aAggregation` 都是独立模块
2. **便于测试**：每个 Post-Search 处理器可以独立测试
3. **易于扩展**：新增处理器不影响现有代码
4. **配置灵活**：可以根据查询类型动态选择处理策略
5. **职责清晰**：SearchEngine 专注检索，Post-Search 专注后处理

## 7. 总结

这个自适应检索引擎策略设计方案既保持了现有架构的灵活性，又引入了智能化的自适应能力，能够针对不同类型的查询提供最优的处理策略。通过独立模块的设计，确保了系统的可扩展性和可维护性。
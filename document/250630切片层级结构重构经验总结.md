# 切片层级结构重构经验总结

## 问题背景

在战锤40K规则RAG问答系统中，用户发现系统召回"猎鹰坦克火力支援"技能时存在召回不准确和内容混杂的问题。经过分析发现，切片的metadata层级（hierarchy）未正确反映文档多级标题结构，导致召回时内容串台和归属错误。

## 核心问题

### 1. 问题现象
- 第30-33行的"分队基础能力：战火风华"内容丢失了正确的层级信息
- "殊途同归 DISPARATE PATHS"被错误地归类到"分队规则"下，而不是应该的"军队规则"下
- 不同顶级section的内容被错误合并到同一个chunk中

### 2. 问题根源
- **Section分割正确**：`_split_headings`方法工作正常
- **问题在chunk优化阶段**：`optimize_chunks`方法中的合并逻辑过于宽松
- **跨section合并**：不同顶级section的chunks被错误合并，导致层级信息混乱

## 重构方法论

### 1. 从错误结果反推逻辑

#### 步骤1：现象观察
```bash
# 发现"战火风华"内容丢失
grep_search("分队基础能力：战火风华", chunks/*.json)
# 发现"殊途同归"被错误归类
grep_search("殊途同归", chunks/*.json)
```

#### 步骤2：结果分析
- 检查切片结果中的层级信息
- 对比原始文档结构
- 识别层级归属错误

#### 步骤3：逻辑反推
- 从错误的chunk内容反推合并过程
- 定位问题出现在哪个处理阶段
- 确定是section分割还是chunk优化的问题

### 2. 标题结构抽取与校验

#### 步骤1：创建标题抽取工具
```python
# test/extract_headings.py
def extract_headings_from_markdown(file_path: str) -> List[Dict[str, Any]]:
    """从Markdown文件中提取标题层级结构"""
    # 支持6级标题的层级栈
    # 构建完整的层级信息
    # 确定内容类型
```

#### 步骤2：生成结构分析报告
```bash
python3 test/extract_headings.py testdata/aeldaricodex.md
```

输出结果：
```
=== 文档结构摘要 ===
总标题数: 127

--- 主要章节结构 ---
  军队规则 (army_rule)
    - 战斗专注 BATTLE FOCUS (army_rule)
    - 殊途同归 DISPARATE PATHS (army_rule)
  分队规则 (detachment_rule)
    - 战火军阵 (WARHOST) (detachment_rule)
      * 分队基础能力：战火风华 (detail_section)
```

#### 步骤3：结构校验
- 对比抽取的标题结构与预期结构
- 验证每个section的层级归属
- 确认内容类型分类的准确性

### 3. 调试与验证

#### 步骤1：创建调试工具
```python
# test/test_section_debug.py
def test_section_splitting_debug():
    """专门调试section分割问题"""
    # 检查section分割结果
    # 查找关键内容的处理情况
    # 验证层级信息正确性
```

#### 步骤2：分阶段调试
```python
def test_chunk_generation():
    """测试chunk生成过程"""
    
def test_optimization():
    """测试chunk优化过程"""
```

#### 步骤3：结果验证
- 检查每个处理阶段的输出
- 对比修复前后的差异
- 确认问题是否彻底解决

## 核心修复点

### 1. 严格的跨section合并检查

#### 修复前的问题逻辑
```python
# 只检查level1是否相同
if current_level1 and last_level1 and current_level1 == last_level1:
    # 合并chunks
```

#### 修复后的严格检查
```python
# 检查level1和section_heading都相同
if current_level1 and last_level1 and current_level1 == last_level1:
    # 额外检查：确保section_heading也相同，避免跨section合并
    current_section_heading = chunk.get('section_heading', '')
    last_section_heading = last_chunk.get('section_heading', '')
    
    # 如果section_heading不同，则不合并（防止跨section合并）
    if current_section_heading != last_section_heading:
        pass  # 不合并
    else:
        # 只有在同一个section内才合并
```

### 2. 层级信息更新策略

#### 修复前的问题
- 合并时简单选择层级更深的chunk的层级信息
- 导致跨section内容被错误归类

#### 修复后的策略
- 只有在同一个section内才进行合并
- 确保合并后的chunk有正确的层级归属

## 重构效果

### 1. 修复前的问题结果
```json
{
  "text": "当你在组建军队时，你可以将丑角单位纳入你的军队...\n\n1.每个大回合开始时，额外获得一个战斗专注指示物...",
  "hierarchy": {
    "level1": "分队规则",
    "level2": "战火军阵 (WARHOST)",
    "level3": "分队基础能力：战火风华"
  }
}
```

### 2. 修复后的正确结果
```json
// 殊途同归 chunk
{
  "text": "当你在组建军队时，你可以将丑角单位纳入你的军队...",
  "hierarchy": {
    "level1": "军队规则",
    "level2": "殊途同归 DISPARATE PATHS"
  }
}

// 战火风华 chunk
{
  "text": "1.每个大回合开始时，额外获得一个战斗专注指示物...",
  "hierarchy": {
    "level1": "分队规则",
    "level2": "战火军阵 (WARHOST)",
    "level3": "分队基础能力：战火风华"
  }
}
```

## 核心经验总结

### 1. 问题定位方法论
- **从现象到本质**：从错误结果反推问题根源
- **分阶段调试**：逐层检查每个处理阶段
- **结构对比**：通过标题抽取工具验证文档结构

### 2. 调试工具设计
- **标题抽取工具**：`extract_headings.py` - 分析文档结构
- **调试脚本**：`test_section_debug.py` - 分阶段调试
- **结果验证**：通过grep和JSON查看验证修复效果

### 3. 代码质量保证
- **严格的条件检查**：防止跨section合并
- **层级信息完整性**：确保每个chunk有正确的层级归属
- **可追溯性**：通过metadata确保内容来源可追溯

### 4. 最佳实践
- **先分析结构，再修复代码**：通过标题抽取理解文档结构
- **分阶段验证**：每个修复步骤都要验证效果
- **工具化调试**：创建专门的调试工具提高效率
- **文档化经验**：记录问题和解决方案，便于后续维护

## 技术要点

### 1. 标题层级栈管理
```python
title_stack = ["" for _ in range(6)]  # 支持6级标题
# 遇到新标题时更新对应层级并清空下级
title_stack[level-1] = title
for i in range(level, 6):
    title_stack[i] = ""
```

### 2. 跨section合并检查
```python
# 双重检查：level1 + section_heading
if current_level1 == last_level1 and current_section_heading == last_section_heading:
    # 只有在同一个section内才合并
```

### 3. 层级信息完整性
```python
hierarchy = {
    'level1': title_stack[0],
    'level2': title_stack[1],
    'level3': title_stack[2],
    # ... 根据实际层级填充
}
```

## 总结

这次重构的核心是通过**从错误结果反推逻辑**和**标题结构抽取校验**的方法，成功解决了切片层级结构问题。关键经验包括：

1. **问题定位**：从现象到本质，分阶段调试
2. **工具设计**：创建专门的调试和验证工具
3. **严格检查**：防止跨section的内容合并
4. **结构保证**：确保层级信息的完整性和正确性

这种方法论不仅解决了当前问题，也为后续类似问题的处理提供了可复用的经验。 
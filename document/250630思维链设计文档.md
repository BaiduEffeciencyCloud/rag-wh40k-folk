# 战锤40K知识图谱架构设计

## 1. 写入时机选择

### 推荐：切片阶段写入
在`data_vector_v3.py`的切片过程中同步构建知识图谱，具体位置：
```python
def _create_chunk_metadata(self, text, heading, level, sentence_count, hierarchy, content_type, extra_metadata):
    # 现有metadata创建逻辑
    metadata = {...}
    
    # 新增：知识图谱实体关系提取
    entities = self._extract_entities(text, heading, hierarchy)
    relationships = self._extract_relationships(text, entities, content_type)
    
    # 写入知识图谱
    self._update_knowledge_graph(entities, relationships, metadata)
    
    return metadata
```

### 优势
- **数据一致性**：切片和知识图谱同步更新
- **性能优化**：避免重复文本处理
- **增量更新**：新文档自动更新知识图谱
- **关系完整性**：在完整上下文中提取实体关系

## 2. 实体关系模型设计

### 2.1 核心实体类型
```cypher
// 单位实体
(:Unit {
    name: "丑角剧团",
    aliases: ["troupe", "harlequin"],
    faction: "阿苏焉尼",
    type: "infantry",
    points: 120
})

// 技能实体
(:Skill {
    name: "死亡之舞",
    aliases: ["death dance"],
    description: "近战阶段开始时选择能力",
    phase: "fight_phase",
    unit: "丑角剧团"
})

// 武器实体
(:Weapon {
    name: "星镖手枪",
    aliases: ["shuriken pistol"],
    type: "pistol",
    range: 12,
    attacks: 1,
    strength: 4
})

// 规则实体
(:Rule {
    name: "冲锋规则",
    phase: "charge_phase",
    description: "移动并进入近战",
    source: "core_rule"
})

// 阶段实体
(:Phase {
    name: "近战阶段",
    aliases: ["fight phase"],
    order: 4,
    description: "进行近战攻击"
})
```

### 2.2 核心关系类型
```cypher
// 单位-技能关系
(:Unit)-[:HAS_SKILL {description: "拥有技能"}]->(:Skill)

// 技能-阶段关系
(:Skill)-[:ACTIVATES_IN {condition: "阶段开始时"}]->(:Phase)

// 单位-武器关系
(:Unit)-[:EQUIPPED_WITH {quantity: "1"}]->(:Weapon)

// 技能-效果关系
(:Skill)-[:PROVIDES_EFFECT {effect: "额外攻击力"}]->(:Effect)

// 规则-阶段关系
(:Rule)-[:APPLIES_IN]->(:Phase)

// 实体-别名关系
(:Unit)-[:ALIAS_OF]->(:Unit)
```

## 3. 技术选型

### 3.1 图数据库选择
**推荐：Neo4j**
- **优势**：
  - 原生图数据库，Cypher查询语言直观
  - 支持复杂图算法和路径查询
  - 丰富的可视化工具
  - 与Python生态集成良好
  - 支持ACID事务

- **替代方案**：
  - **ArangoDB**：多模型数据库，支持文档和图
  - **Amazon Neptune**：云原生图数据库
  - **OrientDB**：多模型数据库

### 3.2 Python客户端
```python
# Neo4j Python驱动
from neo4j import GraphDatabase

# 或者使用Neo4j Python客户端
from py2neo import Graph, Node, Relationship
```

## 4. 实现方案

### 4.1 知识图谱管理器
```python
class KnowledgeGraphManager:
    def __init__(self, neo4j_uri, username, password):
        self.driver = GraphDatabase.driver(neo4j_uri, auth=(username, password))
        
    def extract_entities(self, text, heading, hierarchy):
        """从文本中提取实体"""
        # 使用LLM或规则引擎提取实体
        pass
        
    def extract_relationships(self, text, entities, content_type):
        """提取实体间关系"""
        pass
        
    def update_knowledge_graph(self, entities, relationships, metadata):
        """更新知识图谱"""
        pass
```

### 4.2 实体提取策略
```python
class EntityExtractor:
    def __init__(self):
        self.entity_patterns = {
            'unit': [r'丑角剧团', r'幽冥骑士', r'星际战士'],
            'skill': [r'死亡之舞', r'英雄之勇武', r'阔步巨兽'],
            'weapon': [r'星镖手枪', r'动力剑', r'爆弹枪'],
            'phase': [r'近战阶段', r'射击阶段', r'移动阶段']
        }
        
    def extract_with_llm(self, text):
        """使用LLM提取实体"""
        prompt = f"""
        从以下战锤40K规则文本中提取实体：
        
        文本：{text}
        
        请识别以下类型的实体：
        1. 单位名称（如：丑角剧团、幽冥骑士）
        2. 技能名称（如：死亡之舞、英雄之勇武）
        3. 武器名称（如：星镖手枪、动力剑）
        4. 游戏阶段（如：近战阶段、射击阶段）
        
        返回JSON格式：
        {{
            "entities": [
                {{"text": "实体名称", "type": "实体类型", "confidence": 0.9}}
            ]
        }}
        """
        # 调用LLM获取实体
        pass
```

### 4.3 关系提取策略
```python
class RelationshipExtractor:
    def extract_relationships(self, text, entities):
        """提取实体间关系"""
        relationships = []
        
        # 基于规则的关系提取
        for entity1 in entities:
            for entity2 in entities:
                if entity1 != entity2:
                    relation = self._find_relationship(text, entity1, entity2)
                    if relation:
                        relationships.append(relation)
        
        return relationships
        
    def _find_relationship(self, text, entity1, entity2):
        """查找两个实体间的关系"""
        # 基于关键词和上下文判断关系类型
        pass
```

## 5. 集成方案

### 5.1 修改data_vector_v3.py
```python
class SemanticDocumentChunker:
    def __init__(self, ...):
        # 现有初始化
        from DATAUPLOD.knowledge_graph_manager import KnowledgeGraphManager
        self.knowledge_graph = KnowledgeGraphManager(
            neo4j_uri=os.getenv("NEO4J_URI"),
            username=os.getenv("NEO4J_USERNAME"),
            password=os.getenv("NEO4J_PASSWORD")
        )
    
    def _create_chunk_metadata(self, text, heading, level, sentence_count, hierarchy, content_type, extra_metadata):
        # 现有metadata创建
        metadata = {...}
        
        # 新增：知识图谱更新
        entities = self.knowledge_graph.extract_entities(text, heading, hierarchy)
        relationships = self.knowledge_graph.extract_relationships(text, entities, content_type)
        
        # 异步更新知识图谱（避免阻塞切片过程）
        asyncio.create_task(
            self.knowledge_graph.update_knowledge_graph(entities, relationships, metadata)
        )
        
        return metadata
```

### 5.2 查询优化集成
```python
class QueryProcessorV2:
    def __init__(self):
        # 现有初始化
        from DATAUPLOD.knowledge_graph_manager import KnowledgeGraphManager
        self.knowledge_graph = KnowledgeGraphManager(...)
    
    def parse_query(self, query):
        # 现有查询解析
        parsed_query = super().parse_query(query)
        
        # 新增：知识图谱查询
        kg_results = self.knowledge_graph.query_entities(query)
        
        # 合并结果
        parsed_query.kg_entities = kg_results
        
        return parsed_query
```

## 6. 配置要求

### 6.1 环境变量
```bash
# Neo4j配置
NEO4J_URI=bolt://localhost:7687
NEO4J_USERNAME=neo4j
NEO4J_PASSWORD=your_password

# 可选：Neo4j AuraDB（云服务）
NEO4J_AURA_URI=neo4j+s://your-instance.databases.neo4j.io
```

### 6.2 依赖包
```python
# requirements.txt 新增
neo4j==5.15.0
py2neo==2021.2.3  # 可选，更高级的Python客户端
```

## 7. 实施步骤

### 阶段1：基础架构
1. 安装和配置Neo4j
2. 实现KnowledgeGraphManager基础类
3. 实现简单的实体提取（基于规则）

### 阶段2：智能提取
1. 集成LLM进行实体提取
2. 实现关系提取逻辑
3. 优化实体识别准确性

### 阶段3：查询优化
1. 集成知识图谱查询到QueryProcessorV2
2. 实现基于图的查询扩展
3. 优化检索精度

### 阶段4：高级功能
1. 实现复杂图算法查询
2. 添加知识图谱可视化
3. 实现增量更新和版本管理

## 8. 预期效果

### 8.1 检索精度提升
- **别名处理**：自动识别"troupe"和"丑角剧团"的等价关系
- **关系查询**：支持"丑角剧团有哪些技能"等关系查询
- **上下文理解**：基于实体关系理解查询意图

### 8.2 查询扩展优化
- **实体扩展**：基于知识图谱扩展相关实体
- **关系扩展**：基于实体关系生成相关查询
- **路径查询**：支持复杂的多跳关系查询

### 8.3 答案质量提升
- **实体链接**：准确识别和链接实体
- **关系推理**：基于图结构进行推理
- **完整性检查**：确保答案的实体关系完整性 
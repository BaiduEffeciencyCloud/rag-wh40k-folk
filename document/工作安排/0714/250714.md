# 1.目标

完成sparse值检索并获取到召回数据

# 2.参考的设计文档

document/20250713 sparse检索架构设计.md

# 3. 开发之前的确认

## 3.1. 词典生成和管理的优先级

文档中提到词典生成有多个来源（自动挖掘、人工补充、用户反馈等）。在实施初期，你们希望：
A) 先实现基础的自动词典生成（jieba分词+PMI短语挖掘），快速验证sparse检索效果
B) 还是需要同时实现完整的词典管理功能（包括增量更新、版本管理等）

---

词典生成和管理的问题：
你们已经完成了词典生成和sparse值上传的逻辑
有现成的DICT文件夹在根目录下，包含生成的词典
词典使用逻辑可以参考 dataupload.upsert.UpsertManager._get_latest_vocab_path 方法来获取最新的词典
今天的工作重点将聚焦在根据query进行sparse值检索的工作
也就是说，离线部分（词典生成、chunk稀疏特征编码、数据上传）已经完成，现在需要实现在线检索部分：用户输入query → 分词 → 映射词典 → 生成sparse query向量 → 调用Pinecone进行sparse检索 → 返回召回结果。

---

## 3.2. 稀疏特征编码方案选择

文档提到了多种稀疏特征编码方式（bag-of-words、TF-IDF、BM25等）。你们倾向于：
A) 先使用简单的bag-of-words（词频统计）
B) 直接实现TF-IDF或BM25权重计算
C) 支持多种编码方式的配置切换

---

从`gen_userdict.py`的代码可以看出，你们确实使用的是BM25算法：

1. **词典生成时使用BM25**：在`generate_bm25_manager_from_texts`函数中，创建了`BM25Manager`实例并调用`bm25.fit(texts)`进行训练
2. **稀疏特征编码使用BM25**：`BM25Manager.get_sparse_vector()`方法使用BM25公式计算权重
3. **权重计算**：使用BM25的完整公式，包括k1、b参数和IDF值

**这意味着在进行sparse检索时，必须使用相同的BM25算法来生成query的稀疏向量**，这样才能保证：

- 权重计算方式一致
- 向量空间对齐
- 检索结果的准确性

**复述第二个问题：**
你们在`gen_userdict.py`中使用的是BM25算法来生成词典和训练模型，这意味着在进行sparse检索时，必须使用相同的BM25算法来生成query的稀疏向量，确保权重计算方式和向量空间的一致性。

---

##3. 与现有系统的集成方式

你们现有的RAG系统已经有dense检索，对于sparse检索的集成，希望：
A) 先独立实现sparse检索模块，单独测试效果
B) 直接实现hybrid检索（sparse+dense融合）
C) 设计可配置的检索策略（纯sparse/纯dense/hybrid）

---

与现有系统的集成方式：A) 先独立实现sparse检索模块，单独测试效果
也就是说，我们先专注于实现纯sparse检索功能，验证其召回效果，暂时不考虑与dense检索的hybrid融合。这样可以：
专注核心功能：先确保sparse检索本身工作正常
独立测试效果：可以单独评估sparse检索对穷举类查询的召回率提升
简化开发复杂度：避免同时处理两种检索策略的融合逻辑
便于调试：问题定位更清晰，不会因为hybrid融合逻辑而混淆
复述第三个问题：
你们选择先独立实现sparse检索模块，单独测试其效果，暂时不考虑与现有dense检索的hybrid融合。这样可以专注核心功能，独立验证sparse检索的召回效果。

---

## 4. 测试数据的准备

为了验证sparse检索效果，你们是否有：
A) 现成的WH40K相关文档数据可以直接使用
B) 需要我帮助生成一些模拟的测试数据
C) 有特定的穷举类查询样例可以重点测试

---

测试数据的准备：A) 有现成的WH40K相关文档数据可以直接使用
具体来说，你们提供了test/testdata/aeldaricodex.md作为测试数据，这是一个关于艾达灵族的文档，非常适合用来测试sparse检索效果，特别是穷举类查询如"艾达灵族有多少骑乘单位"等。
复述第四个问题：
你们提供了现成的测试数据test/testdata/aeldaricodex.md，这是一个关于艾达灵族的文档，可以直接用于测试sparse检索功能，验证对穷举类查询的召回效果。

---

# 4.sparse_search的设计

## SparseSearchEngine 设计规划

### 继承关系
- **继承基类**：`BaseSearchEngine`（获取Pinecone和OpenAI初始化）
- **实现接口**：`SearchEngineInterface`（必须实现抽象方法）

### 核心功能函数设计

#### 1. 必须实现的接口方法（继承自SearchEngineInterface）
```python
def search(self, query: Union[str, Dict[str, Any]], top_k: int = 10, **kwargs) -> List[Dict[str, Any]]
```
- **功能**：执行sparse检索的主入口
- **实现**：query分词 → 映射词典 → 生成sparse向量 → Pinecone sparse检索 → 返回结果

```python
def get_type(self) -> str
```
- **功能**：返回搜索引擎类型标识
- **实现**：返回 "sparse"

```python
def get_capabilities(self) -> Dict[str, Any]
```
- **功能**：返回搜索引擎能力信息
- **实现**：返回sparse检索的配置和能力描述

#### 2. 核心业务方法
```python
def _load_bm25_manager(self)
```
- **功能**：加载BM25Manager和词典
- **实现**：调用`dataupload.upsert.UpsertManager._get_latest_vocab_path()`获取最新词典

```python
def _tokenize_query(self, query_text: str) -> List[str]
```
- **功能**：对query进行分词
- **实现**：使用jieba分词，与离线处理保持一致

```python
def _generate_sparse_vector(self, query_text: str) -> Dict[str, List]
```
- **功能**：生成query的sparse向量
- **实现**：使用BM25Manager生成稀疏向量（indices + values）

```python
def _execute_sparse_search(self, sparse_vector: Dict, top_k: int, **kwargs) -> List[Dict]
```
- **功能**：执行Pinecone sparse检索
- **实现**：调用Pinecone的sparse检索接口

#### 3. 辅助方法
```python
def _process_search_results(self, pinecone_response, query_text: str) -> List[Dict]
```
- **功能**：处理Pinecone返回的搜索结果
- **实现**：格式化结果，添加search_type等元信息

```python
def get_sparse_vector_info(self, query_text: str) -> Dict[str, Any]
```

- **功能**：获取query的sparse向量详细信息（调试用）
- **实现**：返回分词结果、词典映射、稀疏向量等信息

### 工厂类集成
需要在`SearchEngineFactory`中添加：
```python
SUPPORTED_TYPES = {
    'dense': DenseSearchEngine,
    'hybrid': HybridSearchEngine,
    'sparse': SparseSearchEngine  # 新增
}
```

### 关键设计要点

#### 1. **一致性保证**：使用与离线处理相同的BM25Manager和词典,sparse检索需要与dense检索保持同样的返回值格式

基于对dense_search和hybrid_search的分析，每个搜索结果项必须包含以下字段：

```python
{
    'doc_id': str,           # 文档ID（来自Pinecone）
    'text': str,             # 文档文本内容
    'score': float,          # 相关性分数
    'metadata': Dict,        # 元数据（来自Pinecone）
    'search_type': str,      # 搜索类型标识
    'query': str             # 原始查询文本
}
```

更新后的核心方法设计

1. 主搜索方法（必须与dense_search格式一致）
```python
def search(self, query: Union[str, Dict[str, Any]], top_k: int = 10, **kwargs) -> List[Dict[str, Any]]:
    """
    执行sparse检索
    Args:
        query: 查询（字符串或结构化查询对象）
        top_k: 返回结果数量
        **kwargs: 其他参数（如filter等）
    Returns:
        List[Dict[str, Any]]: 搜索结果列表，每个结果包含：
        - doc_id (str): 文档ID
        - text (str): 文档文本内容
        - score (float): 相关性分数
        - metadata (Dict): 元数据
        - search_type (str): 搜索类型，固定为'sparse'
        - query (str): 原始查询文本
    """
```

2. 结果处理方法（确保格式一致）

```python
def _process_search_results(self, pinecone_response, query_text: str) -> List[Dict[str, Any]]:
    """
    处理Pinecone返回的搜索结果，确保格式与dense_search一致
    Args:
        pinecone_response: Pinecone查询响应
        query_text: 原始查询文本
    Returns:
        List[Dict[str, Any]]: 格式化的搜索结果列表
    """
    results = []
    for match in pinecone_response.matches:
        text = match.metadata.get('text', '')
        if not text or len(text.strip()) < 10:
            continue
        result = {
            'doc_id': match.id,
            'text': text,
            'score': match.score,
            'metadata': match.metadata,
            'search_type': 'sparse',  # 标识为sparse检索
            'query': query_text
        }
        results.append(result)
    return results
```

3. 其他核心方法（保持不变）
```python
def _load_bm25_manager(self)
def _tokenize_query(self, query_text: str) -> List[str]
def _generate_sparse_vector(self, query_text: str) -> Dict[str, List]
def _execute_sparse_search(self, sparse_vector: Dict, top_k: int, **kwargs) -> List[Dict]
```

4. 接口方法

```python
def get_type(self) -> str:
    """返回搜索引擎类型"""
    return "sparse"

def get_capabilities(self) -> Dict[str, Any]:
    """获取搜索引擎能力信息"""
    return {
        "type": "sparse",
        "description": "基于BM25的稀疏检索",
        "supports_filtering": True,
        "supports_hybrid": False,
        "algorithm": "BM25",
        "index_name": self.index_name
    }
```


#### 2. **错误处理策略**：

- **不抛出异常**：sparse检索失败时不抛出异常，而是返回空列表
- **详细日志记录**：在logger.info中记录详细的错误信息和处理过程，方便追查问题
- **优雅降级**：确保系统稳定性，即使sparse检索失败也不会影响整体流程

##### 更新后的错误处理设计

```python
def search(self, query: Union[str, Dict[str, Any]], top_k: int = 10, **kwargs) -> List[Dict[str, Any]]:
    """
    执行sparse检索
    Args:
        query: 查询（字符串或结构化查询对象）
        top_k: 返回结果数量
        **kwargs: 其他参数（如filter等）
    Returns:
        List[Dict[str, Any]]: 搜索结果列表，失败时返回空列表
    """
    try:
        # 处理查询输入
        if isinstance(query, dict):
            query_text = query.get('text', '')
            if not query_text:
                logger.info("结构化查询中没有找到text字段，返回空结果")
                return []
        else:
            query_text = str(query)
        
        if not query_text.strip():
            logger.info("查询文本为空，返回空结果")
            return []
        
        # 生成sparse向量
        try:
            sparse_vector = self._generate_sparse_vector(query_text)
            logger.info(f"成功生成sparse向量，indices数量: {len(sparse_vector['indices'])}")
        except Exception as e:
            logger.info(f"生成sparse向量失败: {str(e)}，返回空结果")
            return []
        
        # 执行sparse检索
        try:
            results = self._execute_sparse_search(sparse_vector, top_k, **kwargs)
            logger.info(f"Sparse检索完成，查询: {query_text[:50]}...，返回 {len(results)} 个结果")
            return results
        except Exception as e:
            logger.info(f"Pinecone sparse检索失败: {str(e)}，返回空结果")
            return []
            
    except Exception as e:
        logger.info(f"Sparse检索过程中发生未预期错误: {str(e)}，返回空结果")
        return []
```

##### 其他方法的错误处理

```python
def _generate_sparse_vector(self, query_text: str) -> Dict[str, List]:
    """生成query的sparse向量"""
    try:
        # 分词
        tokens = self._tokenize_query(query_text)
        logger.info(f"查询分词结果: {tokens}")
        
        # 生成稀疏向量
        sparse_vector = self.bm25_manager.get_sparse_vector(query_text)
        logger.info(f"BM25稀疏向量生成成功，indices: {sparse_vector['indices'][:5]}...")
        return sparse_vector
        
    except Exception as e:
        logger.info(f"生成sparse向量失败: {str(e)}")
        raise  # 向上抛出，由search方法捕获

def _execute_sparse_search(self, sparse_vector: Dict, top_k: int, **kwargs) -> List[Dict]:
    """执行Pinecone sparse检索"""
    try:
        # 构建搜索参数
        search_params = {
            "sparse_vector": sparse_vector,
            "top_k": top_k,
            "include_metadata": True
        }
        
        # 添加filter参数（如果提供）
        if 'filter' in kwargs:
            search_params['filter'] = kwargs['filter']
        
        # 执行搜索
        response = self.index.query(**search_params)
        logger.info(f"Pinecone sparse检索成功，返回 {len(response.matches)} 个原始结果")
        
        # 处理结果
        results = self._process_search_results(response, query_text)
        return results
        
    except Exception as e:
        logger.info(f"Pinecone sparse检索执行失败: {str(e)}")
        raise  # 向上抛出，由search方法捕获
```

##### 关键特点

1. **不抛出异常**：所有错误都在search方法顶层捕获，返回空列表
2. **详细日志**：每个步骤都有详细的logger.info记录，包括成功和失败情况
3. **问题追查**：通过日志可以清楚看到是在哪个步骤失败的
4. **系统稳定性**：确保即使sparse检索完全失败，也不会影响整体系统


#### 4. **配置管理**：复用现有的config.py配置

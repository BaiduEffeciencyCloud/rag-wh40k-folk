# 250714_下午工作todo.md

## 一、Hybrid 检索开发 TODO

### 1. Pinecone 索引配置

- [ ] 确认 Pinecone index（如 '40ktest'）为 hybrid 检索（vector_type="dense"，metric="dotproduct"），支持 dense+sparse。

### 2. HybridSearchEngine 设计

- [ ] 新增或完善 `HybridSearchEngine` 类，继承 `BaseSearchEngine`，实现 `SearchEngineInterface`。
- [ ] 实现 `search` 方法：支持同时生成 dense 和 sparse 向量，并调用 Pinecone 的 hybrid query。
- [ ] 支持 `alpha` 参数，控制 dense/sparse 融合权重。

### 3. 向量生成与融合

- [ ] 复用/集成 config.py 里定义的 EMBEDDING_MODEL 生成 dense 向量。
- [ ] 复用 BM25Manager 生成 sparse 向量，所有词典和向量化操作均参考 BM25Manager。
- [ ] 在 query 时同时生成 dense 和 sparse 向量，并传入 Pinecone。

### 4. 结果处理与格式统一

- [ ] 处理 Pinecone 返回的 hybrid 检索结果，格式与 dense/sparse 保持一致。
- [ ] 结果中增加 `search_type: "hybrid"` 字段。

### 5. 配置与接口

- [ ] 在 `SearchEngineFactory` 中注册 hybrid 类型。
- [ ] 支持配置切换（dense/sparse/hybrid）。
- [ ] 支持 `alpha`、`top_k`、`filter` 等参数传递，filter 支持灵活传入。

### 6. 测试与验证

- [ ] 编写单元测试和集成测试，验证 hybrid 检索效果和边界情况。
- [ ] 用现有 WH40K 测试数据验证 hybrid 检索的召回和排序效果。

### 7. 日志与监控

- [ ] 日志详细记录每一步是否成功、top_k、alpha、BM25分词结果等（不输出具体向量内容）。

---

## 二、实施前 10 个关键问题与答案

### 1. Dense 向量来源
**答**：dense 向量使用 config.py 里定义的 EMBEDDING_MODEL。

### 2. Alpha 权重默认值
**答**：默认推荐值 0.3。config.py 里如无常量配置，则新建 ALPHA 值。

### 3. 接口兼容性
**答**：hybrid 检索的模块、方法实现方式、返回值都要遵照 dense/sparse 的实现，暂时不用额外返回，后续如有需求再补充。

### 4. 检索策略切换
**答**：目前通过系统参数组装检索过程，未来可扩展为配置/接口参数切换。

### 5. Pinecone 索引现状
**答**：index='40ktest' 应为 hybrid 类型（vector_type="dense"，metric="dotproduct"），如有变动可随时调整。

### 6. Query 输入格式
**答**：search 方法需支持字符串和 dict（结构化 query），dict 可包含 text、filter 等字段，需灵活兼容。

### 7. Filter 支持
**答**：hybrid 检索需支持 Pinecone 的 metadata filter，filter 参数可灵活传入，不传则不调用 filter 逻辑。

### 8. 异常处理与降级策略
**答**：hybrid 检索时，若 sparse vector 生成失败，自动降级为 dense 检索；若 dense embedding 失败，则中断并抛出异常。

### 9. 日志与监控
**答**：日志需详细，记录每一步是否成功、top_k、alpha、BM25分词结果等，但不输出具体向量内容。

### 10. 多模型/多词典支持
**答**：目前只用 config.py 里默认 embedding 和 BM25Manager，未来如需多模型/多词典可扩展。

---

> 备注：所有关于词典、sparse 向量化的操作，均应参考 BM25Manager 类，复用其已有方法和逻辑。 

## 三, 现有 Interface 和factory的实现

Ran tool
### 1. SearchEngineFactory 解读

- **作用**：工厂类，负责根据类型字符串（如 'dense'、'hybrid'、'sparse'）动态创建对应的搜索引擎实例。
- **设计**：
  - `SUPPORTED_TYPES` 字典注册了所有可用的引擎类型及其实现类。
  - `create(engine_type, **kwargs)` 方法根据类型创建实例，返回统一的 `SearchEngineInterface`。
  - `get_supported_types()` 返回所有支持的类型及描述。
  - `get_engine_info(engine_type)` 可获取某种引擎的能力描述（如支持的特性、算法等）。
- **好处**：调用方无需关心具体实现细节，只需传入类型字符串即可获得对应的引擎对象，便于扩展和解耦。

---

### 2. SearchEngineInterface 解读

- **作用**：所有搜索引擎的统一接口（抽象基类），规定了必须实现的核心方法。
- **核心方法**：
  - `search(query, top_k=10, **kwargs)`：主检索方法，支持字符串或结构化 query，返回统一格式的结果列表。
  - `get_type()`：返回引擎类型字符串（如 'dense'、'sparse'、'hybrid'）。
  - `get_capabilities()`：返回引擎能力描述（如支持的检索方式、算法、是否支持 filter/hybrid 等）。
- **好处**：所有引擎实现都必须遵循同一接口，便于工厂和上层业务统一调用和切换。

---

### 3. 实现方式总结

- 你上午的 `SparseSearchEngine` 就是典型实现：继承 `BaseSearchEngine` 和 `SearchEngineInterface`，在 `search` 方法里实现自己的检索逻辑，其他方法（如 `get_type`、`get_capabilities`）也都实现了接口要求。
- `HybridSearchEngine` 也应完全遵循这种模式：  
  - 继承接口和基类  
  - 在 `search` 里实现 hybrid 检索主流程  
  - 保证返回值格式、异常处理、日志等与 dense/sparse 保持一致  
  - 支持工厂注册和统一创建

---

### 4. 结论

- **工厂**：负责统一创建和管理不同类型的搜索引擎实例，便于扩展和解耦。
- **接口**：规定了所有搜索引擎必须实现的核心方法，保证调用方和实现方的契约一致。
- **实现**：每种引擎（dense/sparse/hybrid）都应继承接口和基类，独立实现自己的检索逻辑，返回统一格式的结果。
